# Golang-luckymoney
# 场景概述：
    各种节日
## 红包类型：
    普通红包 或 碰运气红包
# 用例分析与定义：发、收（抢、摇）
    用例定义的主要元素：用例名称、用例描述（who、where、when、what、result）、场景概述、用例价值、约束与限制

## 发红包：
## 正确发送：
    场景：用户发一定数量和金额的红包给一人或多人
    用例描述：选择红包接收人，选择红包类型，设置金额数量，后端验证红包，生成红包并扣除钱包中的余额，发布红包连接（类似秒杀）
## 余额不足：
    场景：用户发红包时，余额不足
    用例描述：同上，并在扣除余额时告知用户余额不足，无法支付
    约束限制：余额不小于红包总金额
## 红包未收：
    场景：用户发红包后，在期限之内未被接收
    用例描述：部分被接收，部分未被接收，将未接收红包退回用户
    约束限制：24小时内接收 

## 收红包：
## 正确收到：
    场景：用户点击红包链接后，抢到红包，将金额加到余额中
    用例描述：同场景
    约束限制：合法用户，正确目标
## 异常：
    场景：点击红包，但未抢到
    用例：同场景
    约束：合法用户，正确目标   
***
## 资金交易：
    交易需求：账户、余额 
    记账与对账：记录资金交易过程和行为
    交易的参与者：交易主体（主动）和交易对象（被动）

## 总结：
    红包即是小金额交易产品：如充值卡、购物卡
    -发红包：从中间商购买和发布
    -收红包：秒杀和兑换
***

## 四色建模法：
    四个概念：
    1.时标性对象-时刻时段原型：业务在时间轴上发生的需要跟踪的事件留下的痕迹
        时标对象生命周期较短，作用范围在生命周期内有效（事务、日志）
        用例用粉色表示
    2.实体对象：业务发生过程中的参与者
        创建后就一直有效（用户、商品）
        用例用绿色表示
    3.角色：存在于时标性对象和实体对象之间
        指实体在业务流程的指责所在（订单类型，用户角色）
        用例用黄色表示
    4.描述：说明实体、时标性对象的属性
        用例用蓝色表示
        
    五个步骤：
    1.寻找需要追溯的事件和足迹，识别出时标性对象
    2.整理时标性对象，得到骨干模型
    3.寻找和分析出事件中的参与者：人、事、物
    4.抽象出角色，并插入对象中
    5.添加对象描述性信息

## 红包业务总体模型分析和设计：

    用户                  收款
    发红包->     检查余额->支付->    收款->  发布红包->发布红包
    --------->时间线---------------------------->
    红包发送记录  **余额记录**  **支付记录**  **收款记录** 红包      红包描述活动记录

    系统任务                           红包商户  用户
    过期检查->保存->  关闭秒杀->标记过期->支付退款->退款入账
    --------->时间线---------------------------->
    红包记录  过期记录 秒杀活动  红包记录  **退款记录**  退款入账记录
    
    
### 子业务模型设计：
    红包资金账户模型分析和设计
    发红包模型分析和设计
    收红包模型分析和设计
    
***
## 数据库设计：
    account表：
        id, 唯一id
        account_no, 账户编号
        account_name, 账户名称
        account_type, 账户类型
        user_id, 用户id
        username, 用户名
        balance, 可用余额
        status, 状态
        created_at, 创建时间
        updated_at; 修改时间
        
    account_log表:
        id, 唯一id
        account_no, 账户编号
        trade_no, 交易单号
        log_no, 流水编号
        target_account_no, 目标账户编号
        user_id, 用户id
        target_user_id, 目标用户id
        amount, 交易金额
        balance, 可用余额
        change_type, 流水交易类型
        change_flag, 交易变化标识
        status, 交易状态
        desc, 交易描述
        create_at; 创建时间
        
## 优化：

***
## 架构设计

## 计算机系统中的数据读取延迟
    -CPU
    一级缓存读取 0.5ns
    分支预测     5ns
    二级缓存读取 7ns
    互斥锁和读锁 100ns
    [相关地址](http://highscalability.com/numbers-everyone-should-know)
    
    -内存
    主内存读取 100ns
    用zip压缩1k字节的数据 10,000ns = 0.01ms
    从主内存中顺序读1MB数据 250,000ns = 0.25ms
    
    -网络
    在1Gbps网络上发送1k数据 10,000ns = 0.01ms
    同一数据中心的往返时间 500,000ns = 0.5ms
    从网络上顺序读取1M数据 10,000,000ns = 10ms
    
    -硬盘
    从SSD硬盘随机读取4K数据 150,000ns = 0.15ms
    从SSD硬盘顺序读取1MB数据 1,000,000ns = 1ms
    磁盘寻道时间 10,000,000ns = 10ms
    从磁盘上顺序读取1M数据 20,000,000ns = 20ms
    
    性能：
    内存>分布式内存>SSD>HDD
    异步>同步
    分布式>单机
    
## 分布式缓存架构：
    提高读写性能->提高并发性能
    1.用户->红包网关->红包服务->(先写缓存)->Cache->(异步同步到数据库)->MySql
    
    2.用户->红包网关->红包服务(本地缓存->分布式缓存->Cache；本地缓存->分布式消息层->MQ->消息消费层->MySQL)
    将本读缓存写入分布式缓存 和本地缓存写入分布式消息 作为一个事务:利用了分布式消息的持久化和顺序写特性（防止缓存崩溃和数据丢失） 和 缓存的高性能读取特性 
    
    3.用户->红包网关->红包服务->Mysql1,Mysql2,Mysql3 用上数据库分片横向扩展（解决数据存储层的瓶颈）