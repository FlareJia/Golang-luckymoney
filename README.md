# Golang-luckymoney
## 环境：
    Go 1.12.9
    验证框架 https://github.com/go-playground/validator
    配置框架 https://github.com/tietang/props
    日志框架 https://github.com/sirupsen/logrus
    数据存储 mysql 8.0
    数据访问 https://github.com/tietang/dbx
    web服务框架 https://github.com/kataras/iris
    测试框架 github.com/smartystreets/goconvy
     
# 场景概述：
    各种节日
## 红包类型：
    普通红包 或 碰运气红包
# 用例分析与定义：发、收（抢、摇）
    用例定义的主要元素：用例名称、用例描述（who、where、when、what、result）、场景概述、用例价值、约束与限制

## 发红包：
## 正确发送：
    场景：用户发一定数量和金额的红包给一人或多人
    用例描述：选择红包接收人，选择红包类型，设置金额数量，后端验证红包，生成红包并扣除钱包中的余额，发布红包连接（类似秒杀）
## 余额不足：
    场景：用户发红包时，余额不足
    用例描述：同上，并在扣除余额时告知用户余额不足，无法支付
    约束限制：余额不小于红包总金额
## 红包未收：
    场景：用户发红包后，在期限之内未被接收
    用例描述：部分被接收，部分未被接收，将未接收红包退回用户
    约束限制：24小时内接收 

## 收红包：
## 正确收到：
    场景：用户点击红包链接后，抢到红包，将金额加到余额中
    用例描述：同场景
    约束限制：合法用户，正确目标
## 异常：
    场景：点击红包，但未抢到
    用例：同场景
    约束：合法用户，正确目标   
***
## 资金交易：
    交易需求：账户、余额 
    记账与对账：记录资金交易过程和行为
    交易的参与者：交易主体（主动）和交易对象（被动）

## 总结：
    红包即是小金额交易产品：如充值卡、购物卡
    :hammer: 发红包：从中间商购买和发布
    :hammer: 收红包：秒杀和兑换
***

## 四色建模法：
    四个概念：
    1.时标性对象-时刻时段原型：业务在时间轴上发生的需要跟踪的事件留下的痕迹
        时标对象生命周期较短，作用范围在生命周期内有效（事务、日志）
        用例用粉色表示
    2.实体对象：业务发生过程中的参与者
        创建后就一直有效（用户、商品）
        用例用绿色表示
    3.角色：存在于时标性对象和实体对象之间
        指实体在业务流程的指责所在（订单类型，用户角色）
        用例用黄色表示
    4.描述：说明实体、时标性对象的属性
        用例用蓝色表示
        
    五个步骤：
    1.寻找需要追溯的事件和足迹，识别出时标性对象
    2.整理时标性对象，得到骨干模型
    3.寻找和分析出事件中的参与者：人、事、物
    4.抽象出角色，并插入对象中
    5.添加对象描述性信息

## 红包业务总体模型分析和设计：

    用户                  收款
    发红包->     检查余额->支付->    收款->  发布红包->发布红包
    --------->时间线---------------------------->
    红包发送记录  **余额记录**  **支付记录**  **收款记录** 红包      红包描述活动记录

    系统任务                           红包商户  用户
    过期检查->保存->  关闭秒杀->标记过期->支付退款->退款入账
    --------->时间线---------------------------->
    红包记录  过期记录 秒杀活动  红包记录  **退款记录**  退款入账记录
    
    
### 子业务模型设计：
    红包资金账户模型分析和设计
    发红包模型分析和设计
    收红包模型分析和设计
    
***
## 数据库设计：
    account表：
        id, 唯一id
        account_no, 账户编号
        account_name, 账户名称
        account_type, 账户类型
        user_id, 用户id
        username, 用户名
        balance, 可用余额
        status, 状态
        created_at, 创建时间
        updated_at; 修改时间
        
    account_log表:
        id, 唯一id
        account_no, 账户编号
        trade_no, 交易单号
        log_no, 流水编号
        target_account_no, 目标账户编号
        user_id, 用户id
        target_user_id, 目标用户id
        amount, 交易金额
        balance, 可用余额
        change_type, 流水交易类型
        change_flag, 交易变化标识
        status, 交易状态
        desc, 交易描述
        create_at; 创建时间
        
## 优化：

***
## 架构设计
    用户 ->(View->红包服务->钱包服务)->MySQL
    
    红包系统特点：事务安全和高并发
    
    高并发高性能解决方案：
        1.数据就近访问
        2.高性能存储
        3.异步减少等待和缓冲
        4.横向扩展：分布式集群
        
        本系统：
        1.高效缓存：分布式缓存和本地缓存
        2.缓冲：消息队列异步化
        3.数据层横向扩展能力：分片
    
    超卖的解决方案：
        1.事务行锁： select for update
            适合：写多，写冲突多的场景
            优点：稳定可靠，不会出现超卖
            缺点：
                需要查询和计算：性能差、锁的阻塞与等待
                锁阻塞或等待会导致客户端延迟或超时
                重试增加系统和网络开销
        2.数据库字段+直接更新：将剩余数量和金额字段设置为无符号整数
            优点：不查询，直接更新
        3.乐观锁：CAS操作
            适合：写少，写冲突少的场景
            

## 计算机系统中的数据读取延迟
    :hammer: CPU
    一级缓存读取 0.5ns
    分支预测     5ns
    二级缓存读取 7ns
    互斥锁和读锁 100ns
    [相关地址](http://highscalability.com/numbers-everyone-should-know)
    
    :hammer: 内存
    主内存读取 100ns
    用zip压缩1k字节的数据 10,000ns = 0.01ms
    从主内存中顺序读1MB数据 250,000ns = 0.25ms
    
    :hammer: 网络
    在1Gbps网络上发送1k数据 10,000ns = 0.01ms
    同一数据中心的往返时间 500,000ns = 0.5ms
    从网络上顺序读取1M数据 10,000,000ns = 10ms
    
    :hammer: 硬盘
    从SSD硬盘随机读取4K数据 150,000ns = 0.15ms
    从SSD硬盘顺序读取1MB数据 1,000,000ns = 1ms
    磁盘寻道时间 10,000,000ns = 10ms
    从磁盘上顺序读取1M数据 20,000,000ns = 20ms
    
    性能：
    内存>分布式内存>SSD>HDD
    异步>同步
    分布式>单机
    
## 分布式缓存架构：
    提高读写性能->提高并发性能
    1.用户->红包网关->红包服务->(先写缓存)->Cache->(异步同步到数据库)->MySql
    
    2.用户->红包网关->红包服务(本地缓存->分布式缓存->Cache；本地缓存->分布式消息层->MQ->消息消费层->MySQL)
    将本读缓存写入分布式缓存 和本地缓存写入分布式消息 作为一个事务:利用了分布式消息的持久化和顺序写特性（防止缓存崩溃和数据丢失） 和 缓存的高性能读取特性 
    
    3.用户->红包网关->红包服务->Mysql1,Mysql2,Mysql3 用上数据库分片横向扩展（解决数据存储层的瓶颈）
    
## 红包算法：
    按照红包总金额和总数量通过红包算法进行拆分后的子红包集合叫 红包序列
    红包序列是随机的，但序列之间的差异性可控
    
    1.简单随机算法： 
        红包序列元素：随机范围（0～最大可用金额） + 最小金额
        缺点：金额先大后小（易出大金额红包）
        
    2.2次随机算法：
    后洗牌算法：
        红包序列元素：随机范围（0～最大可用金额） + 最小金额 再对生成的序列再洗牌打乱
        缺点：需要事先生成整个红包序列（适用于发红包时生成），红包差异较大
    先洗牌算法：
        生成一个一定长度的 红包种子金额序列
        种子金额序列长度控制在3～1/3剩余红包序列
        序列元素为最大可用剩余金额/(n+1)
        最大可用剩余金额 = 剩余金额-最小金额*剩余数量
        再随机一个数，取模计算索引
        按索引从种子金额序列拿出一个金额作为基数
        基数作为最大数随机+最小金额作为红包序列元素
        
        缺点：随着红包数量变大性能急剧下降，红包分布先大后小
    二次随机算法（先洗牌算法的优化）：
        把种子金额序列的生成改成随机生成
        随机种子数量，范围0～2倍剩余数量
        剩余金额除以随机的种子数量
        优点：基本克服了先洗牌再计算的缺点
        缺点：红包金额大且数量小时，最后一个大金额的概率增加
        
    3.2倍均值法：
        关键：控制每次随机值的上限。每个数被控制在0～2倍均值 之间
        
    
    红包计算时机：
    1.发红包时计算（会造成大量存储）
    2.抢红包时计算
    
    ⚠️注意：
    计算时应守住底线，避免0元红包的出现。
    例如：一个总额100的红包，分10个发，平均值为10，每个红包的真实金额在10上下浮动，当其中一个红包大于10，就要从其他红包扣掉多的部分
    故每个红包可被减掉的金额为9.99元，此时可能出现的最小红包为0.01元，可能的最大红包为9.99*9+10 = 99.91元。
    
    公式：
        最大可调度金额 = 总金额 - 最小金额 * 红包数量
        平均可调度金额 = （总金额 - 最小金额 * 红包数量）/ 红包数量
    
    
    